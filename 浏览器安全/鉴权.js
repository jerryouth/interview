1.session-cookie
服务器在接受客户端首次访问时在服务器端创建session，然后保存session(我们可以将session保存在内存中，
也可以保存在redis中，推荐使用后者)，
然后给这个session生成一个唯一的标识字符串,然后在响应头中种下这个唯一标识字符串。


2.加密签名， 对sid 进行加密处理，服务器会根据这个secret 密匙进行解密

3.浏览器中收到请求响应会解析响应头，将sid 保存在本地cookie 中，
浏览器在下次http 请求的请求头中会带上该域名下的cookie 信息

4. 服务器在接收客户端请求时回去解析请求头cookie 中的sid,然后根据这个sid 去找服务器端保存
的该客户端的session，判断该请求是否合法


弊端：

服务器内存消耗大：用户没做一次应用认证，应用就会在服务端做一次记录，
以方便用户下次请求时使用，通常来讲session保存在内存中没随着认证用户的增加，
服务器的消耗就会很大

易收到CSRF攻击:cookie 被截获，用户就很容易被伪造




Token 验证

当用户第一次登录后，服务器生成一个token 并将此token 返回给客户端，以后客户端只需要带上这个token来请求数据

最简单的token 组成：uid time， sign(签名， 由token 的前即为+ 哈希算法压缩成一定常的十六进制字符串，可以防止恶意第三方凭借token 请求服务器)



1.客户端使用用户名跟密码请求登录
2.服务端收到请求，去验证用户名与免密
3.验证成功后，服务端会签发一个Token,再把这个Token发送给客户端
4.客户端收到Token 以后可以把他存储起来，比如放在Cookie 里或者Local Storage里
5.客户端灭磁下个服务端请求资源的时候需要带着服务端签发的TOken
6, 服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据


缺点，
占带宽: 正常情况下token要比 session_id更大，需要消耗更多流量，挤占更多带宽.(不过几乎可以忽略)
性能问题: 相比于session-cookie来说，token需要服务端花费更多的时间和性能来对token进行解密验证.其实Token相比于session-cookie来说就是一个"时间换空间"的方案.



Token 过期与Refresh Token


Token过期
token是访问特定资源的凭证，出于安全考虑,肯定是要有过期时间的。要不然一次登录便可能一直使用，那token认证还有什么意义? token可定是有过期时间的,一般不会很长,不会超高一个小时.

